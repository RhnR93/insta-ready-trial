<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>InstaReady</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>â—ˆ</text></svg>">
<style>
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --bg: #0b0b0e;
  --surface: #141418;
  --border: #27272e;
  --text: #d8d8dc;
  --text2: #78787f;
  --accent: #d4915e;
  --accent-dim: rgba(212,145,94,0.12);
  --green: #5eaa6e;
  --green-dim: rgba(94,170,110,0.12);
  --red: #c45c5c;
  --red-dim: rgba(196,92,92,0.12);
  --yellow: #c9a84c;
  --radius: 10px;
  --font: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
}

html { background: var(--bg); color: var(--text); font-family: var(--font); }
body { min-height: 100dvh; display: flex; flex-direction: column; -webkit-text-size-adjust: 100%; }

.wrap {
  max-width: 440px; width: 100%; margin: 0 auto;
  padding: 24px 16px env(safe-area-inset-bottom, 16px);
  flex: 1; display: flex; flex-direction: column;
}

/* Header */
.hdr { text-align: center; padding: 28px 0 4px; }
.hdr-mark { font-size: 26px; color: var(--accent); margin-bottom: 2px; }
.hdr h1 { font-size: 22px; font-weight: 700; letter-spacing: -0.03em; }
.hdr p { font-size: 13px; color: var(--text2); margin-top: 2px; }

/* Drop zone */
.drop {
  margin-top: 20px;
  border: 1.5px dashed var(--border);
  border-radius: var(--radius);
  padding: 36px 20px;
  text-align: center;
  cursor: pointer;
  transition: border-color 0.2s, background 0.2s;
  position: relative;
}
.drop.compact { padding: 14px 20px; margin-top: 12px; }
.drop:hover, .drop.over { border-color: var(--accent); background: var(--accent-dim); }
.drop-icon { font-size: 28px; color: var(--text2); margin-bottom: 6px; }
.drop.compact .drop-icon { font-size: 18px; margin-bottom: 0; display: inline; margin-right: 6px; }
.drop-label { font-size: 15px; font-weight: 500; }
.drop.compact .drop-label { font-size: 13px; display: inline; }
.drop-hint { font-size: 12px; color: var(--text2); margin-top: 4px; }
.drop.compact .drop-hint { display: none; }
.drop input { position: absolute; inset: 0; opacity: 0; cursor: pointer; }

/* File list */
.file-list { margin-top: 12px; display: flex; flex-direction: column; gap: 6px; }

.fitem {
  padding: 12px 14px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  display: flex; align-items: center; gap: 10px;
  position: relative; overflow: hidden;
  transition: border-color 0.2s;
}
.fitem.done { border-color: var(--green); }
.fitem.error { border-color: var(--red); }
.fitem-icon { font-size: 20px; flex-shrink: 0; }
.fitem-body { flex: 1; min-width: 0; }
.fitem-name {
  font-size: 13px; font-weight: 500;
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.fitem-status { font-size: 11px; color: var(--text2); margin-top: 2px; }
.fitem-status.ok { color: var(--green); }
.fitem-status.err { color: var(--red); }
.fitem-status.warn { color: var(--yellow); }

.fitem-bar {
  position: absolute; bottom: 0; left: 0; height: 3px;
  background: var(--accent); border-radius: 0 2px 0 0;
  transition: width 0.4s ease;
}
.fitem.done .fitem-bar { background: var(--green); }

.fitem-actions { display: flex; gap: 4px; flex-shrink: 0; }
.fitem-btn {
  background: none; border: none; color: var(--text2); font-size: 15px;
  cursor: pointer; padding: 4px 6px; border-radius: 6px; line-height: 1;
  font-family: var(--font);
}
.fitem-btn:hover { color: var(--text); background: var(--border); }
.fitem-btn.dl { color: var(--green); font-size: 13px; font-weight: 600; }
.fitem-btn.dl:hover { background: var(--green-dim); }

/* Format selector */
.formats { margin-top: 16px; }
.formats-label {
  font-size: 11px; color: var(--text2);
  text-transform: uppercase; letter-spacing: 0.06em; margin-bottom: 6px;
}
.fmt-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; }
.fmt-btn {
  background: var(--surface);
  border: 1.5px solid var(--border);
  border-radius: var(--radius);
  padding: 10px 6px;
  text-align: center;
  cursor: pointer;
  transition: border-color 0.15s, background 0.15s;
  color: var(--text);
  font-family: var(--font);
}
.fmt-btn:hover { border-color: var(--accent); }
.fmt-btn.on { border-color: var(--accent); background: var(--accent-dim); }
.fmt-btn:disabled { opacity: 0.4; cursor: not-allowed; }
.fmt-btn strong { display: block; font-size: 12px; font-weight: 600; }
.fmt-btn span { display: block; font-size: 10px; color: var(--text2); margin-top: 1px; }

/* Action bar */
.action-bar { margin-top: 16px; display: flex; gap: 8px; }
.btn {
  flex: 1; padding: 13px 12px;
  border: none; border-radius: var(--radius);
  font-size: 14px; font-weight: 600;
  font-family: var(--font); cursor: pointer;
  transition: opacity 0.15s;
}
.btn:hover { opacity: 0.9; }
.btn:disabled { opacity: 0.35; cursor: not-allowed; }
.btn-primary { background: var(--accent); color: #fff; }
.btn-success { background: var(--green); color: #fff; }
.btn-warn { background: var(--yellow); color: #111; }
.btn-ghost {
  background: var(--surface); color: var(--text2);
  border: 1px solid var(--border); flex: 0 0 auto;
}
.btn-ghost:hover { color: var(--text); }

/* Toast */
.toast {
  position: fixed; bottom: 24px; left: 50%; transform: translateX(-50%);
  background: var(--red); color: #fff; padding: 10px 20px; border-radius: 8px;
  font-size: 13px; font-weight: 500; z-index: 999;
  animation: toastIn 0.2s ease, toastOut 0.3s ease 2.5s forwards;
  pointer-events: none;
}
@keyframes toastIn { from { opacity: 0; transform: translateX(-50%) translateY(12px); } }
@keyframes toastOut { to { opacity: 0; transform: translateX(-50%) translateY(-8px); } }

/* Fine print */
.fine {
  margin-top: auto; padding-top: 24px;
  text-align: center; font-size: 11px;
  color: var(--text2); line-height: 1.6;
}

.hidden { display: none !important; }
</style>
</head>
<body>
<div class="wrap">

  <div class="hdr">
    <div class="hdr-mark">â—ˆ</div>
    <h1>InstaReady</h1>
    <p>Fujifilm â†’ Instagram converter</p>
  </div>

  <!-- Drop zone -->
  <div id="drop" class="drop">
    <div class="drop-icon">â†‘</div>
    <div class="drop-label">Choose photos & videos</div>
    <div class="drop-hint">JPG Â· PNG Â· HEIC Â· MOV Â· MP4 â€” up to 2 GB</div>
    <input type="file" id="fileInput" accept="image/*,video/*,.mov,.mp4,.m4v,.heic,.heif" multiple>
  </div>

  <!-- File list -->
  <div id="fileList" class="file-list"></div>

  <!-- Format selector -->
  <div id="formatSection" class="formats hidden">
    <div class="formats-label">Output format</div>
    <div class="fmt-grid">
      <button class="fmt-btn on" data-fmt="reel"><strong>Reel / Story</strong><span>1080 Ã— 1920</span></button>
      <button class="fmt-btn" data-fmt="feed"><strong>Feed Portrait</strong><span>1080 Ã— 1350</span></button>
      <button class="fmt-btn" data-fmt="square"><strong>Square</strong><span>1080 Ã— 1080</span></button>
    </div>
  </div>

  <!-- Action bars (mutually exclusive) -->
  <div id="actionBar" class="action-bar hidden">
    <button id="btnConvert" class="btn btn-primary">Convert</button>
    <button id="btnClear" class="btn btn-ghost">Clear</button>
  </div>

  <div id="actionBarDone" class="action-bar hidden">
    <button id="btnDownloadAll" class="btn btn-success">â†“ Download all</button>
    <button id="btnReset" class="btn btn-ghost">New batch</button>
  </div>

  <div id="actionBarRetry" class="action-bar hidden">
    <button id="btnDownloadDone" class="btn btn-success">â†“ Download done</button>
    <button id="btnRetryFailed" class="btn btn-warn">Retry failed</button>
    <button id="btnResetRetry" class="btn btn-ghost">Clear</button>
  </div>

  <div class="fine">
    Server-side ffmpeg. No browser re-encoding.<br>
    Audio preserved. Minimizes degradation before Instagram recompresses.
  </div>

</div>

<script>
(function() {
  'use strict';

  const MAX_FILE_BYTES = 2 * 1024 * 1024 * 1024;  // 2 GB â€” must match server
  const POLL_INTERVAL = 800;
  const POLL_MAX_FAILURES = 60;  // ~48s of consecutive failures before giving up

  // â”€â”€ DOM â”€â”€
  const drop        = document.getElementById('drop');
  const fileInput   = document.getElementById('fileInput');
  const fileList    = document.getElementById('fileList');
  const fmtSection  = document.getElementById('formatSection');
  const actionBar   = document.getElementById('actionBar');
  const actionDone  = document.getElementById('actionBarDone');
  const actionRetry = document.getElementById('actionBarRetry');
  const btnConvert  = document.getElementById('btnConvert');
  const btnClear    = document.getElementById('btnClear');
  const btnDlAll    = document.getElementById('btnDownloadAll');
  const btnReset    = document.getElementById('btnReset');
  const btnDlDone   = document.getElementById('btnDownloadDone');
  const btnRetry    = document.getElementById('btnRetryFailed');
  const btnResetR   = document.getElementById('btnResetRetry');
  const fmtBtns     = document.querySelectorAll('.fmt-btn');

  // â”€â”€ State â”€â”€
  let files = [];
  let fileIdSeq = 0;
  let selectedFormat = 'reel';
  let converting = false;

  // â”€â”€ Helpers â”€â”€
  function fmtBytes(n) {
    if (n < 1024) return n + ' B';
    if (n < 1048576) return (n / 1024).toFixed(0) + ' KB';
    if (n < 1073741824) return (n / 1048576).toFixed(1) + ' MB';
    return (n / 1073741824).toFixed(2) + ' GB';
  }

  function fmtDuration(s) {
    if (!s || s <= 0) return '';
    const m = Math.floor(s / 60);
    const sec = Math.round(s % 60);
    return m > 0 ? `${m}m ${sec}s` : `${sec}s`;
  }

  function show(el) { el.classList.remove('hidden'); }
  function hide(el) { el.classList.add('hidden'); }

  function toast(msg) {
    const el = document.createElement('div');
    el.className = 'toast';
    el.textContent = msg;
    document.body.appendChild(el);
    setTimeout(() => { try { document.body.removeChild(el); } catch {} }, 3000);
  }

  function classify(f) {
    if (f.type.startsWith('image/')) return 'image';
    if (f.type.startsWith('video/')) return 'video';
    const ext = f.name.split('.').pop().toLowerCase();
    if (['jpg','jpeg','png','webp','heic','heif','tiff','bmp'].includes(ext)) return 'image';
    if (['mov','mp4','m4v','mkv','avi','webm','mts'].includes(ext)) return 'video';
    return null;
  }

  function escHtml(s) {
    return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
  }

  // â”€â”€ File management â”€â”€
  function addFiles(rawFiles) {
    let rejected = 0;
    for (const f of rawFiles) {
      const type = classify(f);
      if (!type) { rejected++; continue; }

      // Client-side size check â€” don't waste bandwidth uploading >2GB
      if (f.size > MAX_FILE_BYTES) {
        toast(`${f.name} exceeds 2 GB limit.`);
        continue;
      }

      // Duplicate check (name + size)
      if (files.some(e => e.file.name === f.name && e.file.size === f.size)) continue;

      files.push({
        id: ++fileIdSeq, file: f, type,
        status: 'pending', progress: 0,
        jobId: null, xhr: null,
        downloadUrl: null, outputFilename: null,
        outputSize: 0, sourceRes: '', duration: 0,
        error: null, el: null,
      });
    }
    if (rejected > 0) toast(`${rejected} unsupported file(s) skipped.`);
    renderList();
  }

  function removeFile(id) {
    const f = files.find(f => f.id === id);

    // Abort in-progress upload
    if (f?.xhr) {
      try { f.xhr.abort(); } catch {}
      f.xhr = null;
    }

    files = files.filter(f => f.id !== id);
    renderList();
  }

  function clearAll() {
    // Abort any active uploads
    for (const f of files) {
      if (f.xhr) try { f.xhr.abort(); } catch {};
    }
    files = [];
    converting = false;
    renderList();
  }

  // â”€â”€ Render full list â”€â”€
  function renderList() {
    fileList.innerHTML = '';
    const hasFiles = files.length > 0;

    drop.classList.toggle('compact', hasFiles);

    if (!hasFiles) {
      hide(fmtSection); hide(actionBar); hide(actionDone); hide(actionRetry);
      return;
    }

    show(fmtSection);

    for (const f of files) {
      const el = document.createElement('div');
      el.className = 'fitem';
      if (f.status === 'done') el.classList.add('done');
      if (f.status === 'error') el.classList.add('error');

      const icon = f.type === 'video' ? 'ðŸŽ¬' : 'ðŸ–¼';
      let statusText, statusClass = '';

      switch (f.status) {
        case 'pending':
          statusText = fmtBytes(f.file.size);
          break;
        case 'uploading':
          statusText = `Uploadingâ€¦ ${f.progress}%`;
          break;
        case 'converting':
          statusText = `Convertingâ€¦ ${f.progress}%`;
          break;
        case 'done': {
          const parts = ['âœ“', fmtBytes(f.outputSize)];
          if (f.sourceRes) parts.push(f.sourceRes);
          if (f.duration > 0) parts.push(fmtDuration(f.duration));
          statusText = parts.join(' Â· ');
          statusClass = 'ok';
          break;
        }
        case 'error':
          statusText = f.error || 'Failed';
          statusClass = 'err';
          break;
      }

      let actions = '';
      if (f.status === 'done' && f.downloadUrl) {
        actions += `<button class="fitem-btn dl" data-action="dl" data-id="${f.id}">Save</button>`;
      }
      if (!converting) {
        actions += `<button class="fitem-btn" data-action="rm" data-id="${f.id}">âœ•</button>`;
      }

      const barW = f.status === 'done' ? 100
        : (f.status === 'uploading' || f.status === 'converting') ? f.progress
        : 0;

      el.innerHTML = `
        <div class="fitem-icon">${icon}</div>
        <div class="fitem-body">
          <div class="fitem-name">${escHtml(f.file.name)}</div>
          <div class="fitem-status ${statusClass}">${statusText}</div>
        </div>
        <div class="fitem-actions">${actions}</div>
        <div class="fitem-bar" style="width:${barW}%"></div>`;

      f.el = el;
      fileList.appendChild(el);
    }

    updateActionBars();
  }

  // â”€â”€ Incremental UI update for a single file â”€â”€
  function updateFileUI(f) {
    if (!f.el) return;

    f.el.className = 'fitem';
    if (f.status === 'done') f.el.classList.add('done');
    if (f.status === 'error') f.el.classList.add('error');

    const statusEl = f.el.querySelector('.fitem-status');
    if (statusEl) {
      statusEl.className = 'fitem-status';
      switch (f.status) {
        case 'uploading':
          statusEl.textContent = `Uploadingâ€¦ ${f.progress}%`;
          break;
        case 'converting':
          statusEl.textContent = `Convertingâ€¦ ${f.progress}%`;
          break;
        case 'done': {
          const parts = ['âœ“', fmtBytes(f.outputSize)];
          if (f.sourceRes) parts.push(f.sourceRes);
          if (f.duration > 0) parts.push(fmtDuration(f.duration));
          statusEl.textContent = parts.join(' Â· ');
          statusEl.classList.add('ok');
          break;
        }
        case 'error':
          statusEl.textContent = f.error || 'Failed';
          statusEl.classList.add('err');
          break;
      }
    }

    const bar = f.el.querySelector('.fitem-bar');
    if (bar) bar.style.width = (f.status === 'done' ? 100 : f.progress) + '%';

    // Add Save button when done
    if (f.status === 'done' && f.downloadUrl) {
      const actionsEl = f.el.querySelector('.fitem-actions');
      if (actionsEl && !actionsEl.querySelector('.dl')) {
        const dlBtn = document.createElement('button');
        dlBtn.className = 'fitem-btn dl';
        dlBtn.dataset.action = 'dl';
        dlBtn.dataset.id = f.id;
        dlBtn.textContent = 'Save';
        actionsEl.insertBefore(dlBtn, actionsEl.firstChild);
      }
    }
  }

  // â”€â”€ Action bar state machine â”€â”€
  function updateActionBars() {
    hide(actionBar); hide(actionDone); hide(actionRetry);

    if (files.length === 0) return;

    const allSettled = files.every(f => f.status === 'done' || f.status === 'error');
    const anyDone = files.some(f => f.status === 'done');
    const anyError = files.some(f => f.status === 'error');
    const anyPending = files.some(f => f.status === 'pending');

    if (converting) {
      // Show locked action bar
      show(actionBar);
      btnConvert.disabled = true;
      btnConvert.textContent = 'Convertingâ€¦';
      return;
    }

    if (allSettled && anyDone && anyError) {
      // Mixed results â†’ show retry bar
      show(actionRetry);
      const doneN = files.filter(f => f.status === 'done').length;
      const failN = files.filter(f => f.status === 'error').length;
      btnDlDone.textContent = `â†“ Download ${doneN}`;
      btnRetry.textContent = `Retry ${failN} failed`;
    } else if (allSettled && anyDone) {
      // All succeeded
      show(actionDone);
      btnDlAll.textContent = `â†“ Download all (${files.length})`;
    } else if (allSettled && anyError && !anyDone) {
      // All failed â†’ let them retry or clear
      show(actionRetry);
      hide(btnDlDone);
      btnRetry.textContent = `Retry all`;
    } else {
      // Has pending files â†’ show convert bar
      show(actionBar);
      btnConvert.disabled = false;
      const count = files.filter(f => f.status === 'pending' || f.status === 'error').length;
      btnConvert.textContent = count > 1 ? `Convert ${count} files` : 'Convert';
    }

    // Disable format buttons during/after conversion
    fmtBtns.forEach(b => b.disabled = converting);
  }

  // â”€â”€ Event delegation â”€â”€
  fileList.addEventListener('click', e => {
    const btn = e.target.closest('[data-action]');
    if (!btn) return;
    const id = parseInt(btn.dataset.id, 10);
    if (btn.dataset.action === 'rm') removeFile(id);
    if (btn.dataset.action === 'dl') {
      const f = files.find(f => f.id === id);
      if (f?.downloadUrl) triggerDownload(f.downloadUrl, f.outputFilename);
    }
  });

  // â”€â”€ File input & drag-drop â”€â”€
  fileInput.addEventListener('change', () => {
    if (fileInput.files.length) addFiles(Array.from(fileInput.files));
    fileInput.value = '';
  });

  drop.addEventListener('dragover', e => { e.preventDefault(); drop.classList.add('over'); });
  drop.addEventListener('dragleave', () => drop.classList.remove('over'));
  drop.addEventListener('drop', e => {
    e.preventDefault();
    drop.classList.remove('over');
    if (e.dataTransfer?.files.length) addFiles(Array.from(e.dataTransfer.files));
  });

  // â”€â”€ Format selector â”€â”€
  fmtBtns.forEach(btn => btn.addEventListener('click', () => {
    if (converting || btn.disabled) return;
    fmtBtns.forEach(b => b.classList.remove('on'));
    btn.classList.add('on');
    selectedFormat = btn.dataset.fmt;
  }));

  // â”€â”€ Buttons â”€â”€
  btnClear.addEventListener('click', clearAll);
  btnReset.addEventListener('click', clearAll);
  btnResetR.addEventListener('click', clearAll);
  btnConvert.addEventListener('click', startConvert);
  btnRetry.addEventListener('click', retryFailed);

  btnDlAll.addEventListener('click', downloadAllDone);
  btnDlDone.addEventListener('click', downloadAllDone);

  // â”€â”€ Convert â”€â”€
  async function startConvert() {
    converting = true;
    updateActionBars();

    const queue = files.filter(f => f.status === 'pending' || f.status === 'error');

    for (const f of queue) {
      // Check if file was removed while we were processing others
      if (!files.includes(f)) continue;

      try {
        await convertOne(f);
      } catch {
        // Error already set on the file object inside convertOne
      }
    }

    converting = false;
    renderList();  // full re-render to update action buttons
  }

  function retryFailed() {
    // Reset failed files to pending
    for (const f of files) {
      if (f.status === 'error') {
        f.status = 'pending';
        f.progress = 0;
        f.error = null;
      }
    }
    startConvert();
  }

  function convertOne(f) {
    return new Promise((resolve, reject) => {
      f.status = 'uploading';
      f.progress = 0;
      f.error = null;
      updateFileUI(f);

      const form = new FormData();
      form.append('file', f.file);
      form.append('format', selectedFormat);

      const xhr = new XMLHttpRequest();
      f.xhr = xhr;  // store reference for abort
      xhr.open('POST', '/convert');

      xhr.upload.addEventListener('progress', e => {
        if (e.lengthComputable) {
          f.progress = Math.round((e.loaded / e.total) * 100);
          updateFileUI(f);
        }
      });

      xhr.addEventListener('load', () => {
        f.xhr = null;

        if (xhr.status !== 200) {
          let msg = 'Upload failed.';
          if (xhr.status === 413) msg = 'File too large for server.';
          else { try { msg = JSON.parse(xhr.responseText).error || msg; } catch {} }
          f.status = 'error';
          f.error = msg;
          updateFileUI(f);
          reject(new Error(msg));
          return;
        }

        let data;
        try { data = JSON.parse(xhr.responseText); } catch {
          f.status = 'error';
          f.error = 'Invalid server response.';
          updateFileUI(f);
          reject(new Error('Invalid response'));
          return;
        }

        f.jobId = data.jobId;
        f.status = 'converting';
        f.progress = 0;
        updateFileUI(f);

        pollProgress(f).then(resolve).catch(reject);
      });

      xhr.addEventListener('error', () => {
        f.xhr = null;
        f.status = 'error';
        f.error = 'Network error.';
        updateFileUI(f);
        reject(new Error('Network error'));
      });

      xhr.addEventListener('abort', () => {
        f.xhr = null;
        // Don't set error â€” file was intentionally removed
        resolve();
      });

      xhr.send(form);
    });
  }

  function pollProgress(f) {
    return new Promise((resolve, reject) => {
      let failCount = 0;

      const timer = setInterval(async () => {
        try {
          const resp = await fetch('/progress/' + f.jobId);
          if (!resp.ok) {
            clearInterval(timer);
            f.status = 'error';
            f.error = 'Server lost track of this conversion.';
            updateFileUI(f);
            reject(new Error('Job not found'));
            return;
          }

          failCount = 0;  // reset on success
          const data = await resp.json();

          if (data.status === 'processing') {
            f.progress = data.progress || 0;
            updateFileUI(f);
          }

          if (data.status === 'done') {
            clearInterval(timer);
            f.status = 'done';
            f.progress = 100;
            f.downloadUrl = data.downloadUrl;
            f.outputFilename = data.outputFilename;
            f.outputSize = data.outputSize || 0;
            f.duration = data.duration || 0;
            if (data.sourceWidth && data.sourceHeight)
              f.sourceRes = `${data.sourceWidth}Ã—${data.sourceHeight}`;
            updateFileUI(f);
            resolve();
          }

          if (data.status === 'error') {
            clearInterval(timer);
            f.status = 'error';
            f.error = data.error || 'Conversion failed.';
            updateFileUI(f);
            reject(new Error(f.error));
          }
        } catch {
          failCount++;
          if (failCount >= POLL_MAX_FAILURES) {
            clearInterval(timer);
            f.status = 'error';
            f.error = 'Lost connection to server.';
            updateFileUI(f);
            reject(new Error('Polling timeout'));
          }
          // Otherwise keep trying â€” likely a transient network blip
        }
      }, POLL_INTERVAL);
    });
  }

  // â”€â”€ Downloads â”€â”€
  function triggerDownload(url, filename) {
    const a = document.createElement('a');
    a.href = url;
    a.download = filename || '';
    a.style.display = 'none';
    document.body.appendChild(a);
    a.click();
    setTimeout(() => { try { document.body.removeChild(a); } catch {} }, 1000);
  }

  function downloadAllDone() {
    const done = files.filter(f => f.status === 'done' && f.downloadUrl);
    if (done.length === 0) return;

    if (done.length === 1) {
      triggerDownload(done[0].downloadUrl, done[0].outputFilename);
      return;
    }

    // Stagger downloads â€” most browsers handle this fine.
    // iOS Safari may block after the first; users can tap individual Save buttons.
    let blocked = false;
    done.forEach((f, i) => {
      setTimeout(() => {
        triggerDownload(f.downloadUrl, f.outputFilename);
      }, i * 500);
    });

    // Warn iOS users after a short delay
    if (/iPhone|iPad/.test(navigator.userAgent)) {
      setTimeout(() => {
        toast('iOS may block batch downloads. Tap Save on each file if needed.');
      }, 1200);
    }
  }

})();
</script>
</body>
</html>
